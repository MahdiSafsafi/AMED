<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="insn.css" /><meta name="generator" content="iform.xsl" /><title>STZ2G -- A64</title></head><body><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h2 class="instruction-section">STZ2G</h2><p id="desc">
      <p class="aml">Store Allocation Tags, Zeroing stores an Allocation Tag to two Tag granules of memory, zeroing the associated data locations. The address used for the store is calculated from the base register and an immediate signed offset scaled by the Tag granule. The Allocation Tag is calculated from the Logical Address Tag in the source register.</p>
      <p class="aml">This instruction generates an Unchecked access.</p>
    </p>
    <p class="desc">
      It has encodings from 3 classes:
      <a href="#STZ2G_64Spost_ldsttags">Post-index</a>
      , 
      <a href="#STZ2G_64Spre_ldsttags">Pre-index</a>
       and 
      <a href="#STZ2G_64Soffset_ldsttags">Signed offset</a>
    </p>
    <h3 class="classheading"><a name="STZ2G_64Spost_ldsttags" id="STZ2G_64Spost_ldsttags"></a>Post-index<font style="font-size:smaller;"><br />(Armv8.5)
          </font></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">1</td><td class="lr">1</td><td class="lr">1</td><td colspan="9" class="lr">imm9</td><td class="lr">0</td><td class="lr">1</td><td colspan="5" class="lr">Xn</td><td colspan="5" class="lr">Xt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Post-index</h4><p class="asm-code"><a name="STZ2G_64Spost_ldsttags" id="STZ2G_64Spost_ldsttags"></a>STZ2G  <a href="#xt_sp" title="64-bit general-purpose register to be transferred (field &quot;Xt&quot;)">&lt;Xt|SP&gt;</a>, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Xn&quot;)">&lt;Xn|SP&gt;</a>], #<a href="#simm" title="Optional signed immediate offset, multiple of 16 [-4096-4080], default 0 (field &quot;imm9&quot;)">&lt;simm&gt;</a></p></div><p class="pseudocode">integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xn);
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt);
bits(64) offset = <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(<a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(imm9, 64), <a href="shared_pseudocode.html#LOG2_TAG_GRANULE" title="constant integer LOG2_TAG_GRANULE = 4">LOG2_TAG_GRANULE</a>);
boolean writeback = TRUE;
boolean postindex = TRUE;</p>
    <h3 class="classheading"><a name="STZ2G_64Spre_ldsttags" id="STZ2G_64Spre_ldsttags"></a>Pre-index<font style="font-size:smaller;"><br />(Armv8.5)
          </font></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">1</td><td class="lr">1</td><td class="lr">1</td><td colspan="9" class="lr">imm9</td><td class="lr">1</td><td class="lr">1</td><td colspan="5" class="lr">Xn</td><td colspan="5" class="lr">Xt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Pre-index</h4><p class="asm-code"><a name="STZ2G_64Spre_ldsttags" id="STZ2G_64Spre_ldsttags"></a>STZ2G  <a href="#xt_sp" title="64-bit general-purpose register to be transferred (field &quot;Xt&quot;)">&lt;Xt|SP&gt;</a>, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Xn&quot;)">&lt;Xn|SP&gt;</a>, #<a href="#simm" title="Optional signed immediate offset, multiple of 16 [-4096-4080], default 0 (field &quot;imm9&quot;)">&lt;simm&gt;</a>]!</p></div><p class="pseudocode">integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xn);
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt);
bits(64) offset = <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(<a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(imm9, 64), <a href="shared_pseudocode.html#LOG2_TAG_GRANULE" title="constant integer LOG2_TAG_GRANULE = 4">LOG2_TAG_GRANULE</a>);
boolean writeback = TRUE;
boolean postindex = FALSE;</p>
    <h3 class="classheading"><a name="STZ2G_64Soffset_ldsttags" id="STZ2G_64Soffset_ldsttags"></a>Signed offset<font style="font-size:smaller;"><br />(Armv8.5)
          </font></h3><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td class="r">1</td><td class="lr">1</td><td class="lr">1</td><td class="lr">1</td><td colspan="9" class="lr">imm9</td><td class="lr">1</td><td class="lr">0</td><td colspan="5" class="lr">Xn</td><td colspan="5" class="lr">Xt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">Signed offset</h4><p class="asm-code"><a name="STZ2G_64Soffset_ldsttags" id="STZ2G_64Soffset_ldsttags"></a>STZ2G  <a href="#xt_sp" title="64-bit general-purpose register to be transferred (field &quot;Xt&quot;)">&lt;Xt|SP&gt;</a>, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Xn&quot;)">&lt;Xn|SP&gt;</a>{, #<a href="#simm" title="Optional signed immediate offset, multiple of 16 [-4096-4080], default 0 (field &quot;imm9&quot;)">&lt;simm&gt;</a>}]</p></div><p class="pseudocode">integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xn);
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Xt);
bits(64) offset = <a href="shared_pseudocode.html#impl-shared.LSL.2" title="function: bits(N) LSL(bits(N) x, integer shift)">LSL</a>(<a href="shared_pseudocode.html#impl-shared.SignExtend.2" title="function: bits(N) SignExtend(bits(M) x, integer N)">SignExtend</a>(imm9, 64), <a href="shared_pseudocode.html#LOG2_TAG_GRANULE" title="constant integer LOG2_TAG_GRANULE = 4">LOG2_TAG_GRANULE</a>);
boolean writeback = FALSE;
boolean postindex = FALSE;</p>
  <p class="encoding-notes"></p><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Xt|SP&gt;</td><td><a name="xt_sp" id="xt_sp"></a>
        
          <p class="aml">Is the 64-bit name of the general-purpose register to be transferred, encoded in the "Xt" field.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Xn|SP&gt;</td><td><a name="xn_sp" id="xn_sp"></a>
        
          <p class="aml">Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Xn" field.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;simm&gt;</td><td><a name="simm" id="simm"></a>
        
          <p class="aml">Is the optional signed immediate offset, a multiple of 16 in the range -4096 to 4080, defaulting to 0 and encoded in the "imm9" field.</p>
        
      </td></tr></table></div><p class="syntax-notes"></p>
    <div class="ps" psname="commonps"><a name="commonps" id="commonps"></a><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">bits(64) address;
bits(64) data = if t == 31 then <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(width) SP[]">SP</a>[] else <a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]">X</a>[t];
bits(4) tag = <a href="shared_pseudocode.html#AArch64.AllocationTagFromAddress.1" title="function: bits(4) AArch64.AllocationTagFromAddress(bits(64) tagged_address)">AArch64.AllocationTagFromAddress</a>(data);

<a href="shared_pseudocode.html#impl-aarch64.SetTagCheckedInstruction.1" title="function: SetTagCheckedInstruction(boolean checked)">SetTagCheckedInstruction</a>(FALSE);

if n == 31 then
    <a href="shared_pseudocode.html#impl-aarch64.CheckSPAlignment.0" title="function: CheckSPAlignment()">CheckSPAlignment</a>();
    address = <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(width) SP[]">SP</a>[];
else
    address = <a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]">X</a>[n];

if !postindex then
    address = address + offset;

<a href="shared_pseudocode.html#impl-aarch64.Mem.write.3" title="accessor: Mem[bits(64) address, integer size, AccType acctype] = bits(size*8) value">Mem</a>[address, <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1">TAG_GRANULE</a>, <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_NORMAL</a>] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8 * <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1">TAG_GRANULE</a>);
<a href="shared_pseudocode.html#impl-aarch64.Mem.write.3" title="accessor: Mem[bits(64) address, integer size, AccType acctype] = bits(size*8) value">Mem</a>[address+<a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1">TAG_GRANULE</a>, <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1">TAG_GRANULE</a>, <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_NORMAL</a>] = <a href="shared_pseudocode.html#impl-shared.Zeros.1" title="function: bits(N) Zeros(integer N)">Zeros</a>(8 * <a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1">TAG_GRANULE</a>);

<a href="shared_pseudocode.html#AArch64.MemTag.write.2" title="accessor: AArch64.MemTag[bits(64) address, AccType acctype] = bits(4) value">AArch64.MemTag</a>[address, <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_NORMAL</a>] = tag;
<a href="shared_pseudocode.html#AArch64.MemTag.write.2" title="accessor: AArch64.MemTag[bits(64) address, AccType acctype] = bits(4) value">AArch64.MemTag</a>[address+<a href="shared_pseudocode.html#TAG_GRANULE" title="constant integer TAG_GRANULE = 1">TAG_GRANULE</a>, <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW,&#13; AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NONFAULT, AccType_CNOTFIRST, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_NORMAL</a>] = tag;

if writeback then
    if postindex then
        address = address + offset;

    if n == 31 then
        <a href="shared_pseudocode.html#impl-aarch64.SP.write.0" title="accessor: SP[] = bits(width) value">SP</a>[] = address;
    else
        <a href="shared_pseudocode.html#impl-aarch64.X.write.1" title="accessor: X[integer n] = bits(width) value">X</a>[n] = address;</p>
    </div>
  <hr /><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v31.05b, AdvSIMD v29.02, pseudocode v2019-12_rc3_1, sve v2019-12_rc3
      ; Build timestamp: 2019-12-13T11:35
    </p><p class="copyconf">
      Copyright Â© 2010-2019 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
