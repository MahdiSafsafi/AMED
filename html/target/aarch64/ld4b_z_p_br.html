<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><link rel="stylesheet" type="text/css" href="insn.css" /><meta name="generator" content="iform.xsl" /><title>LD4B (scalar plus scalar)</title></head><body><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><hr /><h2 class="instruction-section">LD4B (scalar plus scalar)</h2><p id="desc">Contiguous load four-byte structures to four vectors (scalar index).
          <p></p><p>
      <p class="aml">Contiguous load four-byte structures, each to the same element number in four vector registers from the memory address generated by a 64-bit scalar base and a 64-bit scalar index register and added to the base address. After each structure access the index value is incremented by four. The index register is not updated by the instruction. </p>
      <p class="aml">Each predicate element applies to the same element number in each of the four vector registers, or equivalently to the four consecutive bytes in memory which make up each structure. Inactive elements will not read Device memory or signal a fault, and the corresponding element is set to zero in each of the four destination vector registers.</p>
    </p></p>
    <p class="desc"></p><div class="regdiagram-32"><table class="regdiagram"><thead><tr><td>31</td><td>30</td><td>29</td><td>28</td><td>27</td><td>26</td><td>25</td><td>24</td><td>23</td><td>22</td><td>21</td><td>20</td><td>19</td><td>18</td><td>17</td><td>16</td><td>15</td><td>14</td><td>13</td><td>12</td><td>11</td><td>10</td><td>9</td><td>8</td><td>7</td><td>6</td><td>5</td><td>4</td><td>3</td><td>2</td><td>1</td><td>0</td></tr></thead><tbody><tr class="firstrow"><td class="l">1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td class="r">0</td><td class="lr">0</td><td class="lr">0</td><td class="l">1</td><td class="r">1</td><td colspan="5" class="lr">Rm</td><td class="l">1</td><td>1</td><td class="r">0</td><td colspan="3" class="lr">Pg</td><td colspan="5" class="lr">Rn</td><td colspan="5" class="lr">Zt</td></tr></tbody></table></div><div class="encoding"><h4 class="encoding">SVE</h4><p class="asm-code"><a name="ld4b_z_p_br_contiguous" id="ld4b_z_p_br_contiguous"></a>LD4B    { <a href="#zt1" title="First scalable vector register to be transferred (field &quot;Zt&quot;)">&lt;Zt1&gt;</a>.B, <a href="#zt2" title="Second scalable vector register to be transferred (field Zt)">&lt;Zt2&gt;</a>.B, <a href="#zt3" title="Third scalable vector register to be transferred (field Zt)">&lt;Zt3&gt;</a>.B, <a href="#zt4" title="Fourth scalable vector register to be transferred (field Zt)">&lt;Zt4&gt;</a>.B }, <a href="#pg" title="Governing scalable predicate register P0-P7 (field &quot;Pg&quot;)">&lt;Pg&gt;</a>/Z, [<a href="#xn_sp" title="64-bit general-purpose base register or SP (field &quot;Rn&quot;)">&lt;Xn|SP&gt;</a>, <a href="#xm" title="64-bit general-purpose offset register (field &quot;Rm&quot;)">&lt;Xm&gt;</a>]</p></div><p class="pseudocode">if !HaveSVE() then UNDEFINED;
if Rm == '11111' then UNDEFINED;
integer t = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Zt);
integer n = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rn);
integer m = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Rm);
integer g = <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(Pg);
integer esize = 8;
integer nreg = 4;</p>
  <p class="encoding-notes"></p><h3 class="explanations">Assembler Symbols</h3><div class="explanations"><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Zt1&gt;</td><td><a name="zt1" id="zt1"></a>
        
          <p class="aml">Is the name of the first scalable vector register to be transferred, encoded in the "Zt" field.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Zt2&gt;</td><td><a name="zt2" id="zt2"></a>
        
          <p class="aml">Is the name of the second scalable vector register to be transferred, encoded as "Zt" plus 1 modulo 32.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Zt3&gt;</td><td><a name="zt3" id="zt3"></a>
        
          <p class="aml">Is the name of the third scalable vector register to be transferred, encoded as "Zt" plus 2 modulo 32.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Zt4&gt;</td><td><a name="zt4" id="zt4"></a>
        
          <p class="aml">Is the name of the fourth scalable vector register to be transferred, encoded as "Zt" plus 3 modulo 32.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Pg&gt;</td><td><a name="pg" id="pg"></a>
        
          <p class="aml">Is the name of the governing scalable predicate register P0-P7, encoded in the "Pg" field.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Xn|SP&gt;</td><td><a name="xn_sp" id="xn_sp"></a>
        
          <p class="aml">Is the 64-bit name of the general-purpose base register or stack pointer, encoded in the "Rn" field.</p>
        
      </td></tr></table><table><col class="asyn-l" /><col class="asyn-r" /><tr><td>&lt;Xm&gt;</td><td><a name="xm" id="xm"></a>
        
          <p class="aml">Is the 64-bit name of the general-purpose offset register, encoded in the "Rm" field.</p>
        
      </td></tr></table></div><p class="syntax-notes"></p>
    <div class="ps" psname="commonps"><a name="commonps" id="commonps"></a><h3 class="pseudocode">Operation</h3>
      <p class="pseudocode">CheckSVEEnabled();
integer elements = VL DIV esize;
bits(64) base;
bits(64) addr;
bits(PL) mask = P[g];
bits(64) offset = <a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]">X</a>[m];
constant integer mbytes = esize DIV 8;
array [0..3] of bits(VL) values;

if <a href="shared_pseudocode.html#impl-shared.HaveMTEExt.0" title="function: boolean HaveMTEExt()">HaveMTEExt</a>() then <a href="shared_pseudocode.html#impl-aarch64.SetTagCheckedInstruction.1" title="function: SetTagCheckedInstruction(boolean checked)">SetTagCheckedInstruction</a>(TRUE);

if n == 31 then
    <a href="shared_pseudocode.html#impl-aarch64.CheckSPAlignment.0" title="function: CheckSPAlignment()">CheckSPAlignment</a>();
    base = <a href="shared_pseudocode.html#impl-aarch64.SP.read.0" title="accessor: bits(width) SP[]">SP</a>[];
else
    base = <a href="shared_pseudocode.html#impl-aarch64.X.read.1" title="accessor: bits(width) X[integer n]">X</a>[n];

for e = 0 to elements-1
    addr = base + <a href="shared_pseudocode.html#impl-shared.UInt.1" title="function: integer UInt(bits(N) x)">UInt</a>(offset) * mbytes;
    for r = 0 to nreg-1
        if ElemP[mask, e, esize] == '1' then
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[values[r], e, esize] = <a href="shared_pseudocode.html#impl-aarch64.Mem.read.3" title="accessor: bits(size*8) Mem[bits(64) address, integer size, AccType acctype]">Mem</a>[addr, mbytes, <a href="shared_pseudocode.html#AccType_NORMAL" title="enumeration AccType {AccType_NORMAL, AccType_VEC, AccType_STREAM, AccType_VECSTREAM, AccType_ATOMIC, AccType_ATOMICRW, AccType_ORDERED, AccType_ORDEREDRW, AccType_ORDEREDATOMIC, AccType_ORDEREDATOMICRW, AccType_LIMITEDORDERED, AccType_UNPRIV, AccType_IFETCH, AccType_PTW, AccType_NV2REGISTER,   AccType_DC, AccType_DC_UNPRIV, AccType_IC, AccType_DCZVA, AccType_AT}">AccType_NORMAL</a>];
        else
            <a href="shared_pseudocode.html#impl-shared.Elem.write.3" title="accessor: Elem[bits(N) &amp;vector, integer e, integer size] = bits(size) value">Elem</a>[values[r], e, esize] = <a href="shared_pseudocode.html#impl-shared.Zeros.0" title="function: bits(N) Zeros()">Zeros</a>();
        addr = addr + mbytes;
    offset = offset + nreg;

for r = 0 to nreg-1
    Z[(t+r) MOD 32] = values[r];</p>
    </div>
  <hr /><table align="center"><tr><td><div class="topbar"><a href="index.html">Base Instructions</a></div></td><td><div class="topbar"><a href="fpsimdindex.html">SIMD&amp;FP Instructions</a></div></td><td><div class="topbar"><a href="sveindex.html">SVE Instructions</a></div></td><td><div class="topbar"><a href="encodingindex.html">Index by Encoding</a></div></td><td><div class="topbar"><a href="shared_pseudocode.html">Shared Pseudocode</a></div></td><td><div class="topbar"><a href="notice.html">Proprietary Notice</a></div></td></tr></table><p class="versions">
      Internal version only: isa v31.05b, AdvSIMD v29.02, pseudocode v2019-12_rc3_1, sve v2019-12_rc3
      ; Build timestamp: 2019-12-13T11:35
    </p><p class="copyconf">
      Copyright Â© 2010-2019 Arm Limited or its affiliates. All rights reserved.
      This document is Non-Confidential.
    </p></body></html>
